geom_line(aes(x=time, y=test, color="test"))+
geom_hline(yintercept=beta/(beta+gamma)*lambda,color="blue")+
geom_hline(yintercept=1,color="green")+
xlim(0,100)+
#scale_color_manual(values=c("red", "black","brown"))
labs(y = "R_eff")
beta <- 0.5
gamma <- 0.45
CM_Opt<- ModProc_CM(DDist,beta,gamma,ODEmaxTime = 100, ODEstep = 1e-1,init_theta = it_theta,TrackDyn = T)
MA_Opt<- MASIR_Proc(beta, gamma, lambda, init_S = (N-1)/N, ODEmaxTime=100, ODEstep=1e-1,TrackDyn = T)
Mod_Opt<- MAmod_Proc(beta, gamma, lambda, init_S = (N-1)/N, ODEmaxTime=100, ODEstep=1e-1,TrackDyn = T)
CM_Opt$R0
beta/(beta+gamma)*lambda
Mod_Opt$Rnet/gamma
beta <- 0.05
gamma <- 0.45
beta/(beta+gamma)*lambda
Mod_Opt$Rnet/gamma
CM_Opt<- ModProc_CM(DDist,beta,gamma,ODEmaxTime = 100, ODEstep = 1e-1,init_theta = it_theta,TrackDyn = T)
MA_Opt<- MASIR_Proc(beta, gamma, lambda, init_S = (N-1)/N, ODEmaxTime=100, ODEstep=1e-1,TrackDyn = T)
Mod_Opt<- MAmod_Proc(beta, gamma, lambda, init_S = (N-1)/N, ODEmaxTime=100, ODEstep=1e-1,TrackDyn = T)
CM_Opt$R0
beta/(beta+gamma)*lambda
Mod_Opt$Rnet/gamma
CM_out <- CM_Opt$Dynamic
MA_out <- MA_Opt$Dynamic
Mod_out <- Mod_Opt$Dynamic
time <- CM_out[,1]
CM_I <- CM_out[,5]
MA_I <- MA_out[,3]
Mod_I <- Mod_out[,3]
CM_R <- CM_out[,3]
MA_R <- MA_out[,4]
Mod_R <- Mod_out[,4]
theta <- CM_out[,2]
St<-CM_out[,4]
CM_S <- CM_out[,4]
MA_S <- MA_out[,2]
Mod_S <- Mod_out[,2]
dat_S <- cbind(time,CM_S, MA_S, Mod_S)
dat_R <- cbind(time,CM_R, MA_R, Mod_R)
dat <- cbind(time,CM_I, MA_I, Mod_I)
ggplot(data = dat)+theme_bw()+
geom_line(aes(x=time, y=CM_I,color="Network"))+
geom_point(aes(x=time, y=MA_I,color="MASIR"),alpha=0.1)+
geom_point(aes(x=time, y=Mod_I,color="Modified"),alpha=0.1)+
scale_color_manual(values=c("black", "red","blue"))+
xlim(0,100)+
labs(y = "I(t)")
ggplot(data=dat_S)+theme_bw()+
geom_line(aes(x=time, y=CM_S,color="Network"))+
geom_line(aes(x=time, y=MA_S,color="MASIR"))+
geom_point(aes(x=time, y=Mod_S,color="Modified"),alpha=0.1)+
scale_color_manual(values=c("black", "red","blue"))+
xlim(0,100)+
labs(y = "S(t)")
ggplot(data = dat_R)+theme_bw()+
geom_line(aes(x=time, y=CM_R,color="Network"))+
geom_line(aes(x=time, y=MA_R,color="MASIR"))+
geom_point(aes(x=time, y=Mod_R,color="Modified"),alpha=0.1)+
scale_color_manual(values=c("black", "red","blue"))+
xlim(0,100)+
labs(y = "R(t)")
ggplot(data = dat)+theme_bw()+
geom_line(aes(x=time, y=CM_I,color="Network"))+
geom_point(aes(x=time, y=MA_I,color="MASIR"),alpha=0.1)+
geom_point(aes(x=time, y=Mod_I,color="Modified"),alpha=0.1)+
scale_color_manual(values=c("black", "red","blue"))+
xlim(0,100)+
labs(y = "I(t)")
ggplot(data=dat_S)+theme_bw()+
geom_line(aes(x=time, y=CM_S,color="Network"))+
geom_line(aes(x=time, y=MA_S,color="MASIR"))+
geom_point(aes(x=time, y=Mod_S,color="Modified"),alpha=0.1)+
scale_color_manual(values=c("black", "red","blue"))+
xlim(0,100)+
labs(y = "S(t)")
ggplot(data = dat_R)+theme_bw()+
geom_line(aes(x=time, y=CM_R,color="Network"))+
geom_line(aes(x=time, y=MA_R,color="MASIR"))+
geom_point(aes(x=time, y=Mod_R,color="Modified"),alpha=0.1)+
scale_color_manual(values=c("black", "red","blue"))+
xlim(0,100)+
labs(y = "R(t)")
Mod_S
Mod_I
beta
gamma
lambda
test <- c()
for (i in c(1:1000)){
test[i]<--(CM_S[i+1]-CM_S[i])/CM_I[i]*(lambda/(gamma+beta))
}
test[1001] <- 0
def_reff<- -lambda*CM_S*(-(beta+gamma)*(1+log(CM_S)/lambda)+beta*CM_S+gamma)/(CM_I*(gamma))
cal_reff<- beta/(beta+gamma)*lambda*CM_S
dat_reff <- cbind(time,def_reff,cal_reff,Mod_I,Mod_S,theta,test)
ggplot(data=dat_reff)+theme_bw()+
geom_line(aes(x=time, y=def_reff,color="Def"))+
geom_line(aes(x=time, y=cal_reff,color="cal_eff"))+
#geom_line(aes(x=time, y=disc_reff,color="disc_eff"))+
geom_line(aes(x=time, y=theta, color="Theta"))+
geom_line(aes(x=time, y=test, color="test"))+
geom_hline(yintercept=beta/(beta+gamma)*lambda,color="blue")+
geom_hline(yintercept=1,color="green")+
xlim(0,100)+
#scale_color_manual(values=c("red", "black","brown"))
labs(y = "R_eff")
beta <- 0.1
gamma <- 0.4
CM_Opt<- ModProc_CM(DDist,beta,gamma,ODEmaxTime = 100, ODEstep = 1e-1,init_theta = it_theta,TrackDyn = T)
MA_Opt<- MASIR_Proc(beta, gamma, lambda, init_S = (N-1)/N, ODEmaxTime=100, ODEstep=1e-1,TrackDyn = T)
Mod_Opt<- MAmod_Proc(beta, gamma, lambda, init_S = (N-1)/N, ODEmaxTime=100, ODEstep=1e-1,TrackDyn = T)
CM_Opt$R0
beta/(beta+gamma)*lambda
Mod_Opt$Rnet/gamma
CM_out <- CM_Opt$Dynamic
MA_out <- MA_Opt$Dynamic
Mod_out <- Mod_Opt$Dynamic
time <- CM_out[,1]
CM_I <- CM_out[,5]
MA_I <- MA_out[,3]
Mod_I <- Mod_out[,3]
CM_R <- CM_out[,3]
MA_R <- MA_out[,4]
Mod_R <- Mod_out[,4]
theta <- CM_out[,2]
St<-CM_out[,4]
CM_S <- CM_out[,4]
MA_S <- MA_out[,2]
Mod_S <- Mod_out[,2]
dat_S <- cbind(time,CM_S, MA_S, Mod_S)
dat_R <- cbind(time,CM_R, MA_R, Mod_R)
dat <- cbind(time,CM_I, MA_I, Mod_I)
ggplot(data = dat)+theme_bw()+
geom_line(aes(x=time, y=CM_I,color="Network"))+
geom_point(aes(x=time, y=MA_I,color="MASIR"),alpha=0.1)+
geom_point(aes(x=time, y=Mod_I,color="Modified"),alpha=0.1)+
scale_color_manual(values=c("black", "red","blue"))+
xlim(0,100)+
labs(y = "I(t)")
ggplot(data=dat_S)+theme_bw()+
geom_line(aes(x=time, y=CM_S,color="Network"))+
geom_line(aes(x=time, y=MA_S,color="MASIR"))+
geom_point(aes(x=time, y=Mod_S,color="Modified"),alpha=0.1)+
scale_color_manual(values=c("black", "red","blue"))+
xlim(0,100)+
labs(y = "S(t)")
ggplot(data = dat_R)+theme_bw()+
geom_line(aes(x=time, y=CM_R,color="Network"))+
geom_line(aes(x=time, y=MA_R,color="MASIR"))+
geom_point(aes(x=time, y=Mod_R,color="Modified"),alpha=0.1)+
scale_color_manual(values=c("black", "red","blue"))+
xlim(0,100)+
labs(y = "R(t)")
Mod_S
Mod_I
beta
gamma
lambda
test <- c()
for (i in c(1:1000)){
test[i]<--(CM_S[i+1]-CM_S[i])/CM_I[i]*(lambda/(gamma+beta))
}
test[1001] <- 0
def_reff<- -lambda*CM_S*(-(beta+gamma)*(1+log(CM_S)/lambda)+beta*CM_S+gamma)/(CM_I*(gamma))
cal_reff<- beta/(beta+gamma)*lambda*CM_S
dat_reff <- cbind(time,def_reff,cal_reff,Mod_I,Mod_S,theta,test)
ggplot(data=dat_reff)+theme_bw()+
geom_line(aes(x=time, y=def_reff,color="Def"))+
geom_line(aes(x=time, y=cal_reff,color="cal_eff"))+
#geom_line(aes(x=time, y=disc_reff,color="disc_eff"))+
geom_line(aes(x=time, y=theta, color="Theta"))+
geom_line(aes(x=time, y=test, color="test"))+
geom_hline(yintercept=beta/(beta+gamma)*lambda,color="blue")+
geom_hline(yintercept=1,color="green")+
xlim(0,100)+
#scale_color_manual(values=c("red", "black","brown"))
labs(y = "R_eff")
def_reff<- -lambda*CM_S*(-(beta+gamma)*(1+log(CM_S)/lambda)+beta*CM_S+gamma)/(CM_I*gamma)
cal_reff<- beta/(beta+gamma)*lambda*CM_S
dat_reff <- cbind(time,def_reff,cal_reff,Mod_I,Mod_S,theta,test)
ggplot(data=dat_reff)+theme_bw()+
geom_line(aes(x=time, y=def_reff,color="Def"))+
geom_line(aes(x=time, y=cal_reff,color="cal_eff"))+
#geom_line(aes(x=time, y=disc_reff,color="disc_eff"))+
geom_line(aes(x=time, y=theta, color="Theta"))+
geom_line(aes(x=time, y=test, color="test"))+
geom_hline(yintercept=beta/(beta+gamma)*lambda,color="blue")+
geom_hline(yintercept=1,color="green")+
xlim(0,100)+
#scale_color_manual(values=c("red", "black","brown"))
labs(y = "R_eff")
ggplot(data = dat)+theme_bw()+
geom_line(aes(x=time, y=CM_I,color="Network"))+
geom_point(aes(x=time, y=MA_I,color="MASIR"),alpha=0.1)+
geom_point(aes(x=time, y=Mod_I,color="Modified"),alpha=0.1)+
scale_color_manual(values=c("black", "red","blue"))+
xlim(0,100)+
labs(y = "I(t)")
def_reff<- -lambda*CM_S*(-(beta+gamma)*(1+log(CM_S)/lambda)+beta*CM_S+gamma)/(CM_I)
cal_reff<- beta/(beta+gamma)*lambda*CM_S
dat_reff <- cbind(time,def_reff,cal_reff,Mod_I,Mod_S,theta,test)
ggplot(data=dat_reff)+theme_bw()+
geom_line(aes(x=time, y=def_reff,color="Def"))+
geom_line(aes(x=time, y=cal_reff,color="cal_eff"))+
#geom_line(aes(x=time, y=disc_reff,color="disc_eff"))+
geom_line(aes(x=time, y=theta, color="Theta"))+
geom_line(aes(x=time, y=test, color="test"))+
geom_hline(yintercept=beta/(beta+gamma)*lambda,color="blue")+
geom_hline(yintercept=1,color="green")+
xlim(0,100)+
#scale_color_manual(values=c("red", "black","brown"))
labs(y = "R_eff")
def_reff<- -lambda*CM_S*(-(beta+gamma)*(1+log(CM_S)/lambda)+beta*CM_S+gamma)/(CM_I*gamma)
cal_reff<- beta/(beta+gamma)*lambda*CM_S
dat_reff <- cbind(time,def_reff,cal_reff,Mod_I,Mod_S,theta,test)
ggplot(data=dat_reff)+theme_bw()+
geom_line(aes(x=time, y=def_reff,color="Def"))+
geom_line(aes(x=time, y=cal_reff,color="cal_eff"))+
#geom_line(aes(x=time, y=disc_reff,color="disc_eff"))+
geom_line(aes(x=time, y=theta, color="Theta"))+
geom_line(aes(x=time, y=test, color="test"))+
geom_hline(yintercept=beta/(beta+gamma)*lambda,color="blue")+
geom_hline(yintercept=1,color="green")+
xlim(0,100)+
#scale_color_manual(values=c("red", "black","brown"))
labs(y = "R_eff")
sample(c(1,3,5,7,9),1)
sample(c(1,3,5,7,9),1)
sample(c(1,3,5,7,9),1)
sample(c(1,3,5,7,9),1)
sample(c(1,3,5,7,9),1)
sample(c(1,3,5,7,9),1)
sample(c(1,3,5,7,9),1)
sample(c(1,3,5,7,9),1)
sample(c(1,3,5,7,9),1)
sample(c(1,3,5,7,9),1)
sample(c(1,3,5,7,9),1)
sample(c(1,3,5,7,9),1)
sample(c(1,3,5,7,9),1)
sample(c(1,3,5,7,9),1)
sample(c(1,3,5,7,9),1)
sample(c(1,3,5,7,9),1)
sample(c(1,3,5,7,9),1)
sample(c(1,3,5,7,9),1)
sample(c(1,3,5,7,9),1)
#install.packages("igraph")
library(igraph)
N <- 10000
delta <- 10
# Poisson network
set.seed(15812)
seq <- rpois(N,delta)
### Checking Realization by Erdos-Gallai Thm
EG_check <- function(DegreeDist){
check_vec <- c(0)
DegreeDist <- sort(DegreeDist,decreasing = T)
N <- length(DegreeDist)
Cum <- cumsum(DegreeDist)
#Mark3: corrected Durfee number m
Dlist <- DegreeDist- c(0:(N-1)) >=0
m <- length(which(Dlist==TRUE))
for (k in c(1:m)) {
RHS <- k*(k-1) + k*(length(DegreeDist[which(which(DegreeDist>=k)>k)]))+sum(DegreeDist[which(DegreeDist<k)])
LHS <- Cum[k]
if (LHS<=RHS) {
check_vec[k] <- 1
} else {
check_vec[k] <- 0
}
}
# m<-min(check_vec)
# return(m)
return(!any(check_vec==0))
}
EG_check(seq)
### A bundle check of both even (fast) and EG(formal)
CheckSeq <- function(Seq){
if((sum(Seq)%%2==0) & (EG_check(Seq))){
return(TRUE)
} else {
return(FALSE)
}
}
CheckSeq(seq)
G <- sample_degseq(  seq
, method = "fast.heur.simple"
)
######### SSA Algorithm for transmission
GilAlgo <- function(  Network
, size
, beta
, gamma
, MaxTime
, InitInfSize=1
, TrackDyn=T
){
Net <- Network
G <- as_adj_list(  Net
, mode = "all"
, loops = "once"
, multiple = TRUE
)
Deg_vec <- degree(Net)
N <- size
g <- gamma
b <- beta
ind <- c(1:N)
# random initial infection with size i_0
i_0 <- InitInfSize
###Radomly chose s vertices to be infected
# InitIndex <- c(sample.int(N,i_0))
# Chose infected node with weight of degree
InitIndex <- sample(c(1:N),i_0,prob=Deg_vec)
#Status: S=0, I=1, R=2
#Initialize status and rate
t <- 0
Status <- rep(0,N)
Status[InitIndex] <- 1
Istep <- length(which(Status==1))
if (TrackDyn==T){
NumStep <- 1
t_vec <- c(t)
S_vec <- c(length(which(Status==0))/N)
I_vec <- c(length(which(Status==1))/N)
R_vec <- c(0)
Infect_time <- rep(NA,N)
Infect_time[InitIndex] <- 0
Infect_num <- rep(0,N)
}
Rate <- rep(0,N)
Rate[InitIndex] <- g
for (i in c(1:i_0)) {
x <- InitIndex[i]
# Network neighbor
Neighbor <- as.vector(G[[x]])
# Susceptible neighbor: update their rate
# Contact <- Neighbor[which(Status[Neighbor]==0)]
Contact <- Neighbor[!Status[Neighbor]]
Rate[Contact] <- b
}
cat("Init Sum", sum(Rate),"\n")
cat("Init index", InitIndex,"\n")
# while loop: keep looping if t<tmax & Istep != 0
# i.e. there is still active infection
while(t<MaxTime & Istep != 0){
## SSA Calculation
Sum <- sum(Rate)
Cum <- cumsum(Rate)
# the vertex index of event:
# cat("Sum is", Sum, ",")
r <- runif(2, min = 0, max = 1)
Event <- min(which(Cum>r[1]*Sum))
# Infection: status 0 to 1
# Recovery: status 1 to 2
Status[Event] <- Status[Event]+1
# Network neighbor of event index
Neighbor <- as.vector(G[[Event]])
# Susceptible neighbor: update their rate
Contact <- Neighbor[!Status[Neighbor]]
# cat("contact: ", Contact,"\n")
# Infected neighbor: Potential infectors
Infector <- Neighbor[which(Status[Neighbor]==1)]
## Time spent for event happen
Tstep <- -log(r[2])/Sum
t <- t+Tstep
# cat("Event index is", Event,",")
# cat("Status is", Status[Event],"\n")
# if (Sum<0){
#   return(Rate)
#   break
# }
## Update status
if (Status[Event]==2){               ## Recovery
Rate[Event] <- 0
Rate[Contact] <- Rate[Contact]-b
} else if (Status[Event]==1){        ## Infection
Rate[Event] <- g
Rate[Contact] <- Rate[Contact]+b   ## Independence: linear
if (TrackDyn==T){
# vector of infection time of vertices
# NA if not being infected eventually
Infect_time[Event] <- t
# For each infection event in SSA, we might not be able
# to figure out the exactly one infector as the event is
# determined by the rate of infectee i.e. number of its
# actively infected neighbor.
# But since exponential distribution of infection time
# have the Memorylessness property, and we are assuming all
# neighbor are iid and considering an expectation, we can average
# out the new infection event to all active infected neighbor
# at the moment of event.
# Infect_num[Infector] <- Infect_num[Infector]+1/(length(Infector))
# As suggested by Ben, we now randomly chose one infector (if more than
# one) instead of do the average
samp_inf <- sample(Infector,1)
Infect_num[samp_inf] <- Infect_num[samp_inf]+1
}
} else {
}
## Active number of infections of the whole network
Istep <- length(which(Status==1))
## Update proportion
if (TrackDyn==T){
NumStep <- NumStep+1
t_vec[NumStep] <- t
S_vec[NumStep] <- length(which(Status==0))/N
I_vec[NumStep] <- length(which(Status==1))/N
R_vec[NumStep] <- length(which(Status==2))/N
}
}
## Final sizes
FinishTime <- t
Ssize <- length(which(Status==0))/N
Isize <- length(which(Status==1))/N
Rsize <- length(which(Status==2))/N
FinalStat <- data.frame(FinishTime,Ssize,Isize,Rsize)
if (TrackDyn==T){
Track <- cbind(t_vec,S_vec,I_vec,R_vec)
Infect <- cbind(ind,Infect_time,Infect_num)
return(list(FinalStat=FinalStat,Details=Track,Reff=Infect))
} else {
return(FinalStat)
}
}
beta <- 0.25
gamma <- 0.2
result <- GilAlgo(G, N, beta, gamma, MaxTime = 150)
#
result$FinalStat
result <- GilAlgo(G, N, beta, gamma, MaxTime = 150)
#
result$FinalStat
result <- GilAlgo(G, N, beta, gamma, MaxTime = 150)
#
result$FinalStat
result <- GilAlgo(G, N, beta, gamma, MaxTime = 150)
#
result$FinalStat
result <- GilAlgo(G, N, beta, gamma, MaxTime = 150)
#
result$FinalStat
result <- GilAlgo(G, N, beta, gamma, MaxTime = 150)
#
result$FinalStat
result$Details
result$Reff
result$Details
#
result$FinalStat
result$Details
## rm(list=ls())
## wd <- getwd()
# install.packages("zoo")
### Package Part
library(pracma)
library(zoo)
library(gsl)
library(deSolve)
library(igraph)
library(ggplot2)
library(cbinom)
source("NetworkSimulator.R")
setwd("D:/GitHub/STAT794_BigData_RZ")
library(DBI)
con <- dbConnect(          # use in other settings
RPostgres::Postgres(),
# without the previous and next lines, some functions fail with bigint data
#   so change int64 to integer
bigint = "integer",
host = "localhost",
port = 5432,  # this version still using 5432!!!
user = "postgres",
password = "postgres",
dbname = "Adventureworks"
)
print(con)
library(DBI)
con <- dbConnect(          # use in other settings
RPostgres::Postgres(),
# without the previous and next lines, some functions fail with bigint data
#   so change int64 to integer
bigint = "integer",
host = "localhost",
port = 5432,  # this version still using 5432!!!
user = "postgres",
password = "postgres",
dbname = "Adventureworks"
)
install.packages("RPostgres")
library(DBI)
library(RPostgres)
con <- dbConnect(          # use in other settings
RPostgres::Postgres(),
# without the previous and next lines, some functions fail with bigint data
#   so change int64 to integer
bigint = "integer",
host = "localhost",
port = 5432,  # this version still using 5432!!!
user = "postgres",
password = "postgres",
dbname = "Adventureworks"
)
print(con)
dbExecute(con, "set search_path to sales;")
dbListTables(con)
print(con)
dbExecute(con, "set search_path to sales;")
print(con)
dbExecute(con, "set search_path to sales;")
dbListTables(con)
